init_by_lua_block {

local class     = require "middleclass"
local logger	= require "bunkerweb.logger"
local helpers	= require "bunkerweb.helpers"
local datastore	= require "bunkerweb.datastore"
local cjson		= require "cjson"

-- Start init phase
local init_logger = logger:new("INIT")
local ds = datastore:new()
init_logger:log(ngx.NOTICE, "init phase started")

-- Remove previous data from the datastore
init_logger:log(ngx.NOTICE, "deleting old keys from datastore ...")
local data_keys = {"^plugin_", "^variable_", "^plugins$", "^api_", "^misc_"}
for i, key in pairs(data_keys) do
	local ok, err = ds:delete_all(key)
	if not ok then
		init_logger:log(ngx.ERR, "can't delete " .. key .. " from datastore : " .. err)
		return false
	end
	init_logger:log(ngx.INFO, "deleted " .. key .. " from datastore")
end
init_logger:log(ngx.NOTICE, "deleted old keys from datastore")

-- Load variables into the datastore
init_logger:log(ngx.NOTICE, "saving variables into datastore ...")
local file = io.open("/etc/nginx/variables.env")
if not file then
	init_logger:log(ngx.ERR, "can't open /etc/nginx/variables.env file")
	return false
end
file:close()
for line in io.lines("/etc/nginx/variables.env") do
	local variable, value = line:match("(.+)=(.*)")
	local ok, err = ds:set("variable_" .. variable, value)
	if not ok then
		init_logger:log(ngx.ERR, "can't save variable " .. variable .. " into datastore : " .. err)
		return false
	end
	init_logger:log(ngx.INFO, "saved variable " .. variable .. "=" .. value .. " into datastore")
end
init_logger:log(ngx.NOTICE, "saved variables into datastore")

-- Set misc values into the datastore
init_logger:log(ngx.NOTICE, "saving misc values into datastore ...")
local miscs = {
	reserved_ips = {
		"0.0.0.0/8",
		"10.0.0.0/8",
		"100.64.0.0/10",
		"127.0.0.0/8",
		"169.254.0.0/16",
		"172.16.0.0/12",
		"192.0.0.0/24",
		"192.88.99.0/24",
		"192.168.0.0/16",
		"198.18.0.0/15",
		"198.51.100.0/24",
		"203.0.113.0/24",
		"224.0.0.0/4",
		"233.252.0.0/24",
		"240.0.0.0/4",
		"255.255.255.255/32"
	},
	resolvers = {}
}
local var_resolvers, err = ds:get("variable_DNS_RESOLVERS")
if not var_resolvers then
	init_logger:log(ngx.ERR, "can't get variable DNS_RESOLVERS from datastore : " .. err)
	return false
end
for str_resolver in var_resolvers:gmatch("%S+") do
	table.insert(miscs.resolvers, str_resolver)
end
for k, v in pairs(miscs) do
	local ok, err = ds:set("misc_" .. k, cjson.encode(v))
	if not ok then
		init_logger:log(ngx.ERR, "can't save misc " .. k .. " into datastore : " .. err)
		return false
	end
	init_logger:log(ngx.INFO, "saved misc " .. k .. " into datastore")
end
init_logger:log(ngx.NOTICE, "saved misc values into datastore")

-- Set API values into the datastore
init_logger:log(ngx.NOTICE, "saving API values into datastore ...")
local value, err = ds:get("variable_USE_API")
if not value then
	init_logger:log(ngx.ERR, "can't get variable USE_API from the datastore : " .. err)
	return false
end
if value == "yes" then
	local value, err = ds:get("variable_API_WHITELIST_IP")
	if not value then
		init_logger:log(ngx.ERR, "can't get variable API_WHITELIST_IP from the datastore : " .. err)
		return false
	end
	local whitelists = {}
	for whitelist in value:gmatch("%S+") do
		table.insert(whitelists, whitelist)
	end
	local ok, err = ds:set("api_whitelist_ip", cjson.encode(whitelists))
	if not ok then
		init_logger:log(ngx.ERR, "can't save API whitelist_ip to datastore : " .. err)
		return false
	end
	init_logger:log(ngx.INFO, "saved API whitelist_ip into datastore")
end
init_logger:log(ngx.NOTICE, "saved API values into datastore")

-- Load plugins into the datastore
init_logger:log(ngx.NOTICE, "saving plugins into datastore ...")
local plugins = {}
local plugin_paths = {"/usr/share/bunkerweb/core", "/etc/bunkerweb/plugins"}
for i, plugin_path in ipairs(plugin_paths) do
	local paths = io.popen("find -L " .. plugin_path .. " -maxdepth 1 -type d ! -path " .. plugin_path)
	for path in paths:lines() do
		local ok, plugin = helpers.load_plugin(path .. "/plugin.json")
		if not ok then
			init_logger:log(ngx.ERR, plugin)
		else
			local ok, err = ds:set("plugin_" .. plugin.id, cjson.encode(plugin))
			if not ok then
				init_logger:log(ngx.ERR, "can't save " .. plugin.id .. " into datastore : " .. err)
			else
				table.insert(plugins, plugin)
				table.sort(plugins, function (a, b)
					return a.order < b.order
				end)
				init_logger:log(ngx.NOTICE, "loaded plugin " .. plugin.id .. " v" .. plugin.version)
			end
		end
	end
end
local ok, err = ds:set("plugins", cjson.encode(plugins))
if not ok then
	init_logger:log(ngx.ERR, "can't save plugins into datastore : " .. err)
	return false
end
init_logger:log(ngx.NOTICE, "saved plugins into datastore")

-- Call init() methods
init_logger:log(ngx.NOTICE, "calling init() methods of plugins ...")
for i, plugin in ipairs(plugins) do
	-- Require call
	local plugin_lua, err = helpers.require_plugin(plugin.id)
	if plugin_lua == false then
		init_logger:log(ngx.ERR, err)
	elseif plugin_lua == nil then
		init_logger:log(ngx.NOTICE, err)
	else
		-- Check if plugin has init method
		if plugin_lua.init ~= nil then
			-- New call
			local ok, plugin_obj = helpers.new_plugin(plugin_lua)
			if not ok then
				init_logger:log(ngx.ERR, plugin_obj)
			else
				local ok, ret = helpers.call_plugin(plugin_obj, "init")
				if not ok then
					init_logger:log(ngx.ERR, ret)
				else
					init_logger:log(ngx.NOTICE, plugin.id .. ":init() call successful : " .. ret.msg)
				end
			end
		else
			init_logger:log(ngx.NOTICE, "skipped execution of " .. plugin.id .. " because method init() is not defined")
		end
	end
end
init_logger:log(ngx.NOTICE, "called init() methods of plugins")

init_logger:log(ngx.NOTICE, "init phase ended")

}
